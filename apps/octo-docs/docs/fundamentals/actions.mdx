---
title: Actions
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Definition
An action can be a model action, an overlay action, or a resource action.

An action is how things get done in Octo.
Octo operates by comparing the previous state of a graph with the new state, collecting actions to be executed.
These actions can be one of these types: **add**, **delete**, **update**, or **replace**.

:::info
* A model or overly action manipulates resources, i.e. they transform a model definition into a set of resources.
  * E.g. transforming a Region model into a VPC and an Internet Gateway resource.
* A resource action manipulates the real infrastructure atomically,
i.e. they transform a resource definition to manipulate the real infrastructure using CDK or HTTP requests.
  * E.g. transforming a VPC resource into a real VPC in AWS, and provisioning a real Internet Gateway in AWS.
:::

:::tip
A resource action should ideally be *atomic*, i.e. they should do a single task.
They don't need to be idempotent though,
as Octo will ensure that they are executed in order, one at a time, and only if needed based on the diff.
:::

```mermaid
graph LR;
    model((Model, <br/> Overlay, <br/> or Resource))
    diff{Diff}
    addAction{{Add Action}}
    deleteAction{{Delete Action}}
    replaceAction{{Replace Action}}
    updateAction{{Update Action}}

    model --> diff
    diff --> addAction
    diff --> deleteAction
    diff --> replaceAction
    diff --> updateAction
```

## Node-Action Relationship
A node has `1 : N` relationship with actions, i.e.
an action is always bound to a single node, but a node can have multiple actions.
Their relationship is defined in code, where the action is being defined, using the `@Action` decorator.

<Tabs>
  <TabItem value="modelAction" label="Model Action">
    Here the `AddSimpleAppModelAction` action is bound to the App model node,
    and will only be executed on a qualifying diff of the App node.
    ```typescript
    @Action(App)
    export class AddSimpleAppModelAction implements IModelAction<SimpleAppModule> {
      // implementation.
    }
    ```
  </TabItem>
  <TabItem value="resourceAction" label="Resource Action">
    Here the `AddVpcResourceAction` action is bound to the Vpc resource node,
    and will only be executed on a qualifying diff of the Vpc node.
    ```typescript
    @Action(Vpc)
    export class AddVpcResourceAction implements IResourceAction<Vpc> {
      // implementation.
    }
    ```
  </TabItem>
</Tabs>

## Anatomy
An action primarily consists of 2 methods - `filter()` and `handle()`.

- **Filter**: In this method action defines the conditions when it must run, e.g.
the action must run if the resource is being added, or it must run if a particular property has been updated.
- **Handle**: In this method the action must implement the actual logic, handle retries, and produce outputs.
If an action throws an error, it immediately fails the transaction and Octo captures the current state for the next run.
```typescript title="Action Schema"
{
  filter() // A method that defines the conditions when the action must run.
  handle() // A method that contains the action logic. It also produces outputs.
}
```

## End-to-End Example

The following walkthrough shows how a model action and a resource action chain together
to turn a `SimpleRegion` model into a real AWS VPC.

### Step 1 — Model action creates resources

When Octo diffs the model graph and finds a new `SimpleRegion` node, it selects
`AddSimpleRegionModelAction` because its `filter()` matches.
The `handle()` method creates a `SimpleVpc` resource and returns it in `actionOutputs`.

```typescript title="add-simple-region.model.action.ts"
@Action(SimpleRegion)
export class AddSimpleRegionModelAction implements IModelAction<SimpleRegionModule> {
  filter(diff: Diff): boolean {
    return (
      diff.action === DiffAction.ADD &&
      diff.node instanceof SimpleRegion &&
      hasNodeName(diff.node, 'region') &&
      diff.field === 'regionId'
    );
  }

  async handle(
    diff: Diff<SimpleRegion>,
    actionInputs: EnhancedModuleSchema<SimpleRegionModule>,
    actionOutputs: ActionOutputs,
  ): Promise<ActionOutputs> {
    const region = diff.node;

    // Create a VPC resource for this region.
    const vpc = new SimpleVpc(`vpc-${region.regionId}`, {
      awsAccountId: actionInputs.inputs.account.accountId,
      awsAvailabilityZones: [...region.awsRegionAZs],
      awsRegionId: region.awsRegionId,
      CidrBlock: actionInputs.inputs.vpcCidrBlock,
      InstanceTenancy: 'default',
    });

    actionOutputs[vpc.resourceId] = vpc;
    return actionOutputs;
  }
}
```

### Step 2 — Resource action calls the cloud API

After all model actions complete, Octo diffs the resource graph.
It finds the new `SimpleVpc` and selects `AddSimpleVpcResourceAction`.
The `handle()` method calls the AWS SDK and writes the resulting VPC ID back to
`resource.response` via `setResponse()` so that downstream resources can reference it.

```typescript title="add-simple-vpc.resource.action.ts"
@Action(SimpleVpc)
export class AddSimpleVpcResourceAction implements IResourceAction<SimpleVpc> {
  filter(diff: Diff): boolean {
    return (
      diff.action === DiffAction.ADD &&
      diff.node instanceof SimpleVpc &&
      hasNodeName(diff.node, 'simple-vpc') &&
      diff.field === 'resourceId'
    );
  }

  async handle(diff: Diff<SimpleVpc>): Promise<SimpleVpcSchema['response']> {
    const vpc = diff.node;
    const { awsAccountId, awsRegionId, CidrBlock, InstanceTenancy } = vpc.properties;

    const ec2Client = await this.container.get<EC2Client, typeof EC2ClientFactory>(EC2Client, {
      args: [awsAccountId, awsRegionId],
      metadata: { package: '@octo' },
    });

    const vpcOutput = await ec2Client.send(
      new CreateVpcCommand({ CidrBlock, InstanceTenancy }),
    );

    // Write the cloud-assigned VPC ID back onto the resource.
    return {
      VpcId: vpcOutput.Vpc!.VpcId!,
      VpcArn: `arn:aws:ec2:${awsRegionId}:${awsAccountId}:vpc/${vpcOutput.Vpc!.VpcId}`,
    };
  }
}
```

### How they chain

```mermaid
graph LR;
    region((SimpleRegion <br/> model))
    modelDiff{Model Diff}
    modelAction{{AddSimpleRegionModelAction}}
    vpc([SimpleVpc <br/> resource])
    resourceDiff{Resource Diff}
    resourceAction{{AddSimpleVpcResourceAction}}
    aws[(AWS VPC)]

    region --> modelDiff
    modelDiff --> modelAction
    modelAction -- "creates" --> vpc
    vpc --> resourceDiff
    resourceDiff --> resourceAction
    resourceAction -- "provisions" --> aws
```

1. The **model action** transforms intent (the `SimpleRegion` model) into resources (`SimpleVpc`).
2. The **resource action** transforms the resource definition into real cloud infrastructure.
3. The response (`VpcId`) is written back to the resource via `setResponse()` and persisted
   in state for the next run.

:::tip
See the [`@Action` decorator API reference](/api/octo/function/Action) for the full decorator signature,
and the [`AResource.setResponse` API reference](/api/octo/class/AResource) for response handling details.
:::

## Summary
In this section we've explored Actions. This is where the "it" happens.
Most of the logic that makes up your infrastructure will happen in these Action files.
We've also discussed why Actions are the most likely place to throw errors, and can cause transactions to fail.
