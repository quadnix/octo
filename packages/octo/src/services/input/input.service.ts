import type { UnknownModel, UnknownOverlay, UnknownResource } from '../../app.type.js';
import { Factory } from '../../decorators/factory.decorator.js';
import { Container } from '../../functions/container/container.js';
import type { ANode } from '../../functions/node/node.abstract.js';
import { OverlayDataRepository } from '../../overlays/overlay-data.repository.js';
import { ResourceDataRepository } from '../../resources/resource-data.repository.js';

export class InputService {
  private inputs: { [key: string]: unknown } = {};

  private models: { [key: string]: UnknownModel } = {};

  private overlays: { [key: string]: string } = {};

  private resources: { [key: string]: string } = {};

  constructor(
    private readonly overlayDataRepository: OverlayDataRepository,
    private readonly resourceDataRepository: ResourceDataRepository,
  ) {}

  getModuleIdFromModel(model: UnknownModel): string {
    const modelContext = model.getContext();
    const [key] = Object.entries(this.models).find(([, m]) => m.getContext() === modelContext)!;
    return key.split('.')[0];
  }

  getModuleIdFromOverlay(overlay: UnknownOverlay): string {
    const overlayContext = overlay.getContext();
    const [key] = Object.entries(this.overlays).find(([, o]) => o === overlayContext)!;
    return key.split('.')[0];
  }

  getModuleIdFromResource(resource: UnknownResource): string {
    const context = resource.getContext();
    const [key] = Object.entries(this.resources).find(([, r]) => r === context)!;
    return key.split('.')[0];
  }

  /**
   * Registers the inputs passed to an instance of module.
   * It maps the input key provided to the module with the input value.
   * The value can be a direct value, or can be a reference "${}" to
   * another input, module, overlay, or resource.
   */
  registerInput(moduleId: string, key: string, value: unknown): void {
    const inputKey = `${moduleId}.input.${key}`;
    if (this.inputs.hasOwnProperty(inputKey)) {
      throw new Error(`Input "${inputKey}" has already been registered!`);
    }
    this.inputs[inputKey] = value;
  }

  /**
   * Registers the model generated by an instance of module.
   * The key is a reference to the model generated by the module, and maps directly to the model instance.
   */
  registerModel(moduleId: string, model: UnknownModel): void {
    const modelKey = `${moduleId}.model.${(model.constructor as typeof ANode).NODE_NAME}`;
    if (this.models.hasOwnProperty(modelKey)) {
      throw new Error(`Model "${modelKey}" has already been registered!`);
    }
    this.models[modelKey] = model;
  }

  /**
   * Registers the overlay generated by an instance of module.
   * The key is a reference to the overlay generated by the module, and maps to the overlay context.
   */
  registerOverlay(moduleId: string, overlay: UnknownOverlay): void {
    const overlayKey = `${moduleId}.overlay.${overlay.overlayId}`;
    if (this.overlays.hasOwnProperty(overlayKey)) {
      throw new Error(`Overlay "${overlayKey}" has already been registered!`);
    }
    this.overlays[overlayKey] = overlay.getContext();
  }

  /**
   * Registers the resource generated by an instance of module.
   * The key is a reference to the resource generated by the module, and maps to the resource context.
   */
  registerResource(moduleId: string, resource: UnknownResource): void {
    const resourceKey = `${moduleId}.resource.${resource.resourceId}`;
    if (this.resources.hasOwnProperty(resourceKey)) {
      throw new Error(`Resource "${resourceKey}" has already been registered!`);
    }
    this.resources[resourceKey] = resource.getContext();
  }

  resolve(key: string): unknown | undefined {
    key = this.resolveInputKey(key);
    const keyParts = key.split('.');

    switch (keyParts[1]) {
      case 'input':
        return this.inputs[key];
      case 'model':
        const model = this.models[keyParts.slice(0, 3).join('.')];
        if (!model) {
          return undefined;
        }
        return this.resolveObjectPath(model, keyParts.slice(3).join('.'));
      case 'overlay':
        const overlayContext = this.overlays[keyParts.slice(0, 3).join('.')];
        const overlay = this.overlayDataRepository.getByContext(overlayContext);
        if (!overlay) {
          return undefined;
        }
        return this.resolveObjectPath(overlay, keyParts.slice(3).join('.'));
      case 'resource':
        const resourceContext = this.resources[keyParts.slice(0, 3).join('.')];
        const resource = this.resourceDataRepository.getNewResourceByContext(resourceContext);
        if (!resource) {
          return undefined;
        }
        return this.resolveObjectPath(resource, keyParts.slice(3).join('.'));
      default:
        return undefined;
    }
  }

  /**
   * Given an input key, returns the resolved input key.
   * An input key is resolved when the value is not a pointer to another input.
   * Otherwise, an input key could be referencing another input, module, overlay, or resource.
   * E.g. module.input.key = ${another_module.input.key}
   * This method traverses the value of the input key recursively until it is resolved.
   */
  private resolveInputKey(inputKey: string, maxRecursion = 15, originalInputKey?: string): string {
    if (maxRecursion === 0) {
      throw new Error(`Input "${originalInputKey}" could not be resolved!`);
    }

    const value = this.inputs[inputKey];

    // If an input key is not found, or is not a string, it is either undefined, or is a non-input value.
    // In this case, the value is resolved and the current input key is returned.
    if (!value || typeof value !== 'string') {
      return inputKey;
    }

    // An input key without the ${} pattern is already resolved.
    const pattern = value.match(/^\$\{(.+)}$/);
    if (!pattern) {
      return inputKey;
    }

    return this.resolveInputKey(pattern[1], maxRecursion - 1, originalInputKey || inputKey);
  }

  // https://stackoverflow.com/a/69459511/1834562
  private resolveObjectPath(subject: object, path: string): any {
    if (!path.length) {
      return subject;
    }

    return path.split('.').reduce((obj, key) => obj && obj[key], subject);
  }
}

@Factory<InputService>(InputService)
export class InputServiceFactory {
  private static instance: InputService;

  static async create(forceNew: boolean = false): Promise<InputService> {
    const overlayDataRepository = await Container.getInstance().get(OverlayDataRepository);
    const resourceDataRepository = await Container.getInstance().get(ResourceDataRepository);

    if (!this.instance) {
      this.instance = new InputService(overlayDataRepository, resourceDataRepository);
    }

    if (forceNew) {
      this.instance['inputs'] = {};
      this.instance['models'] = {};
      this.instance['overlays'] = {};
      this.instance['resources'] = {};
    }

    return this.instance;
  }
}
