import {
  type ActionInputs,
  type Constructable,
  type IUnknownModelAction,
  type IUnknownResourceAction,
  NodeType,
  type TransactionOptions,
  type UnknownModel,
  type UnknownOverlay,
  type UnknownResource,
} from '../../app.type.js';
import { EventSource } from '../../decorators/event-source.decorator.js';
import { Factory } from '../../decorators/factory.decorator.js';
import {
  InputNotFoundTransactionError,
  InputRegistrationError,
  ResourceActionExceptionTransactionError,
  ResourceActionTimeoutTransactionError,
  TransactionError,
} from '../../errors/index.js';
import {
  ModelActionRegistrationEvent,
  ModelActionTransactionEvent,
  ModelDiffsTransactionEvent,
  ModelTransactionTransactionEvent,
  ResourceActionCompletedTransactionEvent,
  ResourceActionInitiatedTransactionEvent,
  ResourceActionRegistrationEvent,
  ResourceActionSummaryTransactionEvent,
  ResourceDiffsTransactionEvent,
  ResourceTransactionTransactionEvent,
} from '../../events/index.js';
import { Container } from '../../functions/container/container.js';
import { DiffMetadata } from '../../functions/diff/diff-metadata.js';
import { type Diff, DiffAction } from '../../functions/diff/diff.js';
import { DiffUtility } from '../../functions/diff/diff.utility.js';
import type { ANode } from '../../functions/node/node.abstract.js';
import type { AModel } from '../../models/model.abstract.js';
import { ModuleContainer } from '../../modules/module.container.js';
import { OverlayDataRepository } from '../../overlays/overlay-data.repository.js';
import { AOverlay } from '../../overlays/overlay.abstract.js';
import { ResourceDataRepository } from '../../resources/resource-data.repository.js';
import { AResource } from '../../resources/resource.abstract.js';
import { CaptureService } from '../capture/capture.service.js';
import { EventService } from '../event/event.service.js';
import { InputService } from '../input/input.service.js';

export class TransactionService {
  private modelActions: { modelClass: Constructable<UnknownModel>; actions: IUnknownModelAction[] }[] = [];
  private overlayActions: { overlayClass: Constructable<UnknownOverlay>; actions: IUnknownModelAction[] }[] = [];
  private resourceActions: { resourceClass: Constructable<UnknownResource>; actions: IUnknownResourceAction[] }[] = [];

  constructor(
    private readonly captureService: CaptureService,
    private readonly eventService: EventService,
    private readonly inputService: InputService,
    private readonly moduleContainer: ModuleContainer,
    private readonly overlayDataRepository: OverlayDataRepository,
    private readonly resourceDataRepository: ResourceDataRepository,
  ) {}

  private async applyModels(diffs: DiffMetadata[]): Promise<DiffMetadata[][]> {
    const transaction: DiffMetadata[][] = [];

    let currentApplyOrder = 0;
    let processed = 0;

    while (processed < diffs.length) {
      const diffsInSameLevel = diffs.filter((d) => d.applyOrder === currentApplyOrder);
      const diffsProcessedInSameLevel: DiffMetadata[] = [];

      for (const diff of diffsInSameLevel) {
        if (diff.applied) {
          continue;
        }

        // Check for duplicate diffs on the same model and same field.
        const duplicateDiffs = this.getDuplicateDiffs(diff, diffsInSameLevel);

        // Only process the first diff, given all duplicate diffs are the same.
        const diffToProcess = duplicateDiffs[0].diff;

        for (const a of diff.actions as IUnknownModelAction[]) {
          // Find moduleId.
          let moduleId: string;
          if (diff.node instanceof AOverlay) {
            moduleId = this.inputService.getModuleIdFromOverlay(diff.node);
          } else {
            moduleId = this.inputService.getModuleIdFromModel(diff.node as UnknownModel);
          }

          // Resolve all keys of the module - inputs keys and nodes generated by the module keys.
          const inputs: ActionInputs = { inputs: {}, metadata: {}, models: {}, overlays: {}, resources: {} };
          const inputKeys = this.moduleContainer.getModuleInstanceInputKeys(moduleId).map((i) => {
            return `${moduleId}.input.${i}`;
          });
          const metadataKeys = this.inputService.getMetadataKeys(moduleId);
          const nodeKeys = this.inputService.getAllNodeKeys(moduleId);
          const allKeys = [...inputKeys, ...metadataKeys, ...nodeKeys];

          for (const k of allKeys) {
            const inputValue = this.inputService.resolve(k);
            if (inputValue === undefined) {
              throw new InputNotFoundTransactionError(
                'No matching input found to process action!',
                a,
                diffToProcess,
                k,
              );
            }

            const keyValue = k.split('.')[2];
            if (k.startsWith(`${moduleId}.input`)) {
              inputs.inputs[keyValue] = inputValue;
            } else if (k.startsWith(`${moduleId}.metadata`)) {
              inputs.metadata[keyValue] = inputValue;
            } else if (k.startsWith(`${moduleId}.model`)) {
              inputs.models[keyValue] = inputValue as UnknownModel;
            } else if (k.startsWith(`${moduleId}.overlay`)) {
              inputs.overlays[keyValue] = inputValue as UnknownOverlay;
            } else if (k.startsWith(`${moduleId}.resource`)) {
              inputs.resources[keyValue] = inputValue as UnknownResource;
            }
          }

          // Apply all actions on the diff, then update diff metadata with inputs and outputs.
          const outputs = await a.handle(diffToProcess, inputs, {});
          for (const resource of Object.values(outputs)) {
            let moduleId: string;
            if (diffToProcess.node instanceof AOverlay) {
              moduleId = this.inputService.getModuleIdFromOverlay(diffToProcess.node);
            } else {
              moduleId = this.inputService.getModuleIdFromModel(diffToProcess.node as UnknownModel);
            }

            // Set resource tags.
            const resourceTags = this.inputService.resolve(`${moduleId}.tag.${resource.getContext()}`) as {
              [key: string]: string;
            };
            for (const [key, value] of Object.entries(resourceTags)) {
              resource.tags[key] = value;
            }

            const previousResource = this.resourceDataRepository.getNewResourceByContext(resource.getContext());
            if (previousResource) {
              resource.merge(previousResource);
            } else {
              this.resourceDataRepository.addNewResource(resource);
            }

            try {
              this.inputService.registerResource(moduleId, resource);
            } catch (error) {
              if (!(error instanceof InputRegistrationError)) {
                throw error;
              }
            }
          }

          duplicateDiffs.forEach((d) => {
            d.updateInputs(inputs);
            d.updateOutputs(outputs);
          });

          this.eventService.emit(new ModelActionTransactionEvent(a.constructor.name));
        }

        // Include the diff to process in the list of diffs processed in the same level.
        diffsProcessedInSameLevel.push(duplicateDiffs[0]);

        // Mark metadata of each duplicate diffs as applied.
        duplicateDiffs.forEach((d) => (d.applied = true));
      }

      // Add all diff in same level to transaction.
      transaction.push(diffsProcessedInSameLevel);

      processed += diffsInSameLevel.length;
      currentApplyOrder += 1;
    }

    return transaction;
  }

  private async applyResources(
    diffs: DiffMetadata[],
    { enableResourceCapture = false }: { enableResourceCapture?: boolean } = {},
  ): Promise<DiffMetadata[][]> {
    const transaction: DiffMetadata[][] = [];

    let currentApplyOrder = 0;
    let processed = 0;

    while (processed < diffs.length) {
      const diffsInSameLevel = diffs.filter((d) => d.applyOrder === currentApplyOrder);
      const diffsProcessedInSameLevel: DiffMetadata[] = [];

      for (const diff of diffsInSameLevel) {
        if (diff.applied) {
          continue;
        }

        // Check for duplicate diffs on the same resource and same field.
        const duplicateDiffs = this.getDuplicateDiffs(diff, diffsInSameLevel);

        // Only process the first diff, given all duplicate diffs are the same.
        const diffToProcess = duplicateDiffs[0].diff;

        for (const a of diff.actions as IUnknownResourceAction[]) {
          this.eventService.emit(
            new ResourceActionInitiatedTransactionEvent(a.constructor.name, diff.node.getContext()),
          );

          if (enableResourceCapture) {
            const capture = this.captureService.getCapture((diff.node as UnknownResource).getContext());
            await a.mock(diff, capture?.response || {});
            await a.handle(diffToProcess);
          } else {
            let actionTimeoutId: NodeJS.Timeout | undefined;
            try {
              await Promise.race([
                new Promise<void>(async (resolve, reject) => {
                  try {
                    await a.handle(diffToProcess);
                    resolve();
                  } catch (error) {
                    reject(
                      new ResourceActionExceptionTransactionError(
                        error.message,
                        error,
                        diffToProcess,
                        a.constructor.name,
                      ),
                    );
                  }
                }),
                new Promise(
                  (_resolve, reject) =>
                    (actionTimeoutId = setTimeout(() => {
                      reject(
                        new ResourceActionTimeoutTransactionError(
                          `Resource action ${a.constructor.name} timed out after ${a.actionTimeoutInMs || 90000}ms!`,
                          diffToProcess,
                          a.constructor.name,
                        ),
                      );
                    }, a.actionTimeoutInMs || 90000)), // 1.5 minutes.
                ),
              ]);
            } finally {
              if (actionTimeoutId) {
                clearTimeout(actionTimeoutId);
              }
            }
          }

          // De-reference from actual resources.
          const deReferenceResource = async (context: string): Promise<UnknownResource> => {
            return this.resourceDataRepository.getActualResourceByContext(context)!;
          };

          // Incrementally apply diff inverse to the respective actual resource.
          let actualResource = this.resourceDataRepository.getActualResourceByContext(diffToProcess.node.getContext())!;
          if (!actualResource) {
            actualResource = await AResource.cloneResource(diffToProcess.node as UnknownResource, deReferenceResource);
            this.resourceDataRepository.addActualResource(actualResource);
            this.eventService.emit(
              new ResourceActionSummaryTransactionEvent(a.constructor.name, {
                diffAction: diffToProcess.action,
                diffField: diffToProcess.field,
                resourceId: actualResource.resourceId,
                values: { current: actualResource.synth(), previous: {} },
              }),
            );
          } else {
            const previousSynth = actualResource.synth();
            await actualResource.diffInverse(diffToProcess, deReferenceResource);
            this.eventService.emit(
              new ResourceActionSummaryTransactionEvent(a.constructor.name, {
                diffAction: diffToProcess.action,
                diffField: diffToProcess.field,
                resourceId: actualResource.resourceId,
                values: { current: actualResource.synth(), previous: previousSynth },
              }),
            );
          }

          this.eventService.emit(
            new ResourceActionCompletedTransactionEvent(a.constructor.name, diff.node.getContext()),
          );
        }

        // Include the diff to process in the list of diffs processed in the same level.
        diffsProcessedInSameLevel.push(duplicateDiffs[0]);

        // Mark metadata of each duplicate diffs as applied.
        duplicateDiffs.forEach((d) => (d.applied = true));
      }

      // Add all diff in same level to transaction.
      transaction.push(diffsProcessedInSameLevel);

      processed += diffsInSameLevel.length;
      currentApplyOrder += 1;
    }

    return transaction;
  }

  private getDiffsOfSameNode(diff: DiffMetadata, diffs: DiffMetadata[], diffAction: DiffAction): DiffMetadata[] {
    return diffs.filter((d) => d.node.getContext() === diff.node.getContext() && d.action === diffAction);
  }

  private getDuplicateDiffs(diff: DiffMetadata, diffs: DiffMetadata[]): DiffMetadata[] {
    return diffs.filter(
      (d) =>
        d.node.getContext() === diff.node.getContext() &&
        d.field === diff.field &&
        d.action === diff.action &&
        DiffUtility.isObjectDeepEquals(d.value, diff.value),
    );
  }

  private getMatchingDiffs(diff: DiffMetadata, diffs: DiffMetadata[]): DiffMetadata[] {
    return diffs.filter(
      (d) =>
        d.node.getContext() === diff.node.getContext() &&
        d.field === diff.field &&
        DiffUtility.isObjectDeepEquals(d.value, diff.value),
    );
  }

  /**
   * Before assigning order to a diff, all its node's parent diffs must be processed.
   * E.g. diff to add environment, depends on region to exist, thus add region diff gets processed first.
   */
  private setApplyOrder(diff: DiffMetadata, diffs: DiffMetadata[], seen: DiffMetadata[] = []): void {
    // Detect circular dependencies.
    if (this.getDuplicateDiffs(diff, seen).length > 0) {
      throw new TransactionError('Found circular dependencies!');
    }

    // Detect conflicting actions in transaction.
    const matchingDiffs = this.getMatchingDiffs(diff, diffs);
    const diffActions = matchingDiffs.reduce((accumulator, currentValue) => {
      accumulator[currentValue.action] = true;
      return accumulator;
    }, {});
    if (diffActions[DiffAction.ADD] && diffActions[DiffAction.DELETE]) {
      throw new TransactionError('Found conflicting actions in same transaction!');
    }

    // Skip processing diff that already has the applyOrder set.
    if (diff.applyOrder >= 0) {
      return;
    }

    // Get all dependencies of subject node.
    const dependencies = diff.node.getDependencies();
    const dependencyApplyOrders: number[] = [-1];

    for (const dependency of dependencies) {
      // Iterate diffs looking to match dependency on same field and action.
      const matchingParentDiffs = diffs.filter(
        (d) =>
          d.node.getContext() === dependency.to.getContext() &&
          dependency.hasMatchingBehavior(diff.field, diff.action, d.field, d.action),
      );

      // On each diff that should be processed first, apply order on it before than self.
      for (const matchingParentDiff of matchingParentDiffs) {
        this.setApplyOrder(matchingParentDiff, diffs, [...seen, diff]);
        dependencyApplyOrders.push(matchingParentDiff.applyOrder);
      }
    }

    // Get diffs of same node.
    // Process ADD before UPDATE, and UPDATE before DELETE.
    if (diff.action === DiffAction.UPDATE) {
      const diffsOfSameNodeWithAddAction = this.getDiffsOfSameNode(diff, diffs, DiffAction.ADD);
      for (const sameNodeDiffWithAddAction of diffsOfSameNodeWithAddAction) {
        this.setApplyOrder(sameNodeDiffWithAddAction, diffs, [...seen, diff]);
        dependencyApplyOrders.push(sameNodeDiffWithAddAction.applyOrder);
      }
    } else if (diff.action === DiffAction.DELETE) {
      const diffsOfSameNodeWithUpdateAction = this.getDiffsOfSameNode(diff, diffs, DiffAction.UPDATE);
      for (const sameNodeDiffWithUpdateAction of diffsOfSameNodeWithUpdateAction) {
        this.setApplyOrder(sameNodeDiffWithUpdateAction, diffs, [...seen, diff]);
        dependencyApplyOrders.push(sameNodeDiffWithUpdateAction.applyOrder);
      }
    }

    diff.applyOrder = Math.max(...dependencyApplyOrders) + 1;
  }

  async *beginTransaction(
    diffs: Diff[],
    {
      enableResourceCapture = false,
      yieldModelDiffs = false,
      yieldModelTransaction = false,
      yieldResourceDiffs = false,
      yieldResourceTransaction = false,
    }: TransactionOptions = {},
  ): AsyncGenerator<DiffMetadata[][], DiffMetadata[][]> {
    // Diff overlays and add to existing diffs.
    diffs.push(...(await this.overlayDataRepository.diff()));

    // Generate diff on models.
    const modelDiffs = diffs.map((d) => {
      if ((d.node.constructor as typeof ANode).NODE_TYPE === NodeType.OVERLAY) {
        return new DiffMetadata(
          d,
          (
            this.overlayActions.find(
              (a) => (a.overlayClass as unknown as typeof AOverlay) === (d.node.constructor as typeof AOverlay),
            )?.actions || []
          ).filter((a) => a.filter(d)),
        );
      } else {
        return new DiffMetadata(
          d,
          (
            this.modelActions.find(
              (a) => (a.modelClass as unknown as typeof AModel) === (d.node.constructor as typeof AModel),
            )?.actions || []
          ).filter((a) => a.filter(d)),
        );
      }
    });
    // Set apply order on model diffs.
    for (const diff of modelDiffs) {
      this.setApplyOrder(diff, modelDiffs);
    }

    this.eventService.emit(new ModelDiffsTransactionEvent(undefined, [modelDiffs]));
    if (yieldModelDiffs) {
      yield [modelDiffs];
    }

    // Apply model diffs.
    const modelTransaction = await this.applyModels(modelDiffs);

    this.eventService.emit(new ModelTransactionTransactionEvent(undefined, modelTransaction));
    if (yieldModelTransaction) {
      yield modelTransaction;
    }

    // Generate resource diffs.
    const newDiffs = await this.resourceDataRepository.diff();
    const dirtyDiffs = await this.resourceDataRepository.diffDirty();

    // new diffs = new - old | dirty diffs = new - actual
    // Any new diff that is also not part of dirty diffs should be skipped, as the actual is already in desired state.
    for (let i = newDiffs.length - 1; i >= 0; i--) {
      const newDiff = newDiffs[i];
      if (
        !dirtyDiffs.some(
          (d) =>
            d.node.getContext() === newDiff.node.getContext() &&
            d.action === newDiff.action &&
            d.field === newDiff.field &&
            DiffUtility.isObjectDeepEquals(d.value, newDiff.value),
        )
      ) {
        newDiffs.splice(i, 1);
      }
    }

    // Ensure any new diffs are not operating on dirty resources.
    this.resourceDataRepository.ensureDiffsNotOperatingOnDirtyResources(newDiffs);

    // Skip processing dirty diffs that are already accounted for in new diffs.
    for (let i = dirtyDiffs.length - 1; i >= 0; i--) {
      const dirtyDiff = dirtyDiffs[i];
      if (
        newDiffs.some(
          (d) =>
            d.node.getContext() === dirtyDiff.node.getContext() &&
            d.action === dirtyDiff.action &&
            d.field === dirtyDiff.field &&
            DiffUtility.isObjectDeepEquals(d.value, dirtyDiff.value),
        )
      ) {
        dirtyDiffs.splice(i, 1);
      }
    }

    // Generate diff on resources.
    const resourceDiffs = newDiffs.map(
      (d) =>
        new DiffMetadata(
          d,
          (
            this.resourceActions.find(
              (a) => (a.resourceClass as unknown as typeof AResource) === (d.node.constructor as typeof AResource),
            )?.actions || []
          ).filter((a) => a.filter(d)),
        ),
    );
    // Set apply order on resource diffs.
    for (const diff of resourceDiffs) {
      this.setApplyOrder(diff, resourceDiffs);
    }
    // Generate diff on dirty resources.
    const dirtyResourceDiffs = dirtyDiffs.map(
      (d) =>
        new DiffMetadata(
          d,
          (
            this.resourceActions.find(
              (a) => (a.resourceClass as unknown as typeof AResource) === (d.node.constructor as typeof AResource),
            )?.actions || []
          ).filter((a) => a.filter(d)),
        ),
    );
    // Set apply order on dirty resource diffs.
    for (const diff of dirtyResourceDiffs) {
      this.setApplyOrder(diff, dirtyResourceDiffs);
    }

    this.eventService.emit(new ResourceDiffsTransactionEvent(undefined, [[resourceDiffs], [dirtyResourceDiffs]]));
    if (yieldResourceDiffs) {
      yield [resourceDiffs, dirtyResourceDiffs];
    }

    // Apply resource diffs.
    const resourceTransaction = await this.applyResources(resourceDiffs, {
      enableResourceCapture,
    });
    // Apply dirty resource diffs.
    const dirtyResourceTransaction = await this.applyResources(dirtyResourceDiffs, {
      enableResourceCapture,
    });

    this.eventService.emit(
      new ResourceTransactionTransactionEvent(undefined, [resourceTransaction, dirtyResourceTransaction]),
    );
    if (yieldResourceTransaction) {
      yield [...resourceTransaction, ...dirtyResourceTransaction];
    }

    return modelTransaction;
  }

  @EventSource(ModelActionRegistrationEvent)
  registerModelActions(forModel: Constructable<UnknownModel>, actions: IUnknownModelAction[]): void {
    const modelActions = this.modelActions.find((a) => a.modelClass === forModel);
    if (!modelActions) {
      this.modelActions.push({ actions: actions, modelClass: forModel });
    } else {
      for (const action of actions) {
        if (modelActions.actions.find((a) => a.constructor.name === action.constructor.name)) {
          throw new Error(`Action "${action.constructor.name}" already registered for model "${forModel.name}"!`);
        }
        modelActions.actions.push(action);
      }
    }
  }

  @EventSource(ModelActionRegistrationEvent)
  registerOverlayActions(forOverlay: Constructable<UnknownOverlay>, actions: IUnknownModelAction[]): void {
    const overlayActions = this.overlayActions.find((a) => a.overlayClass === forOverlay);
    if (!overlayActions) {
      this.overlayActions.push({ actions: actions, overlayClass: forOverlay });
    } else {
      for (const action of actions) {
        if (overlayActions.actions.find((a) => a.constructor.name === action.constructor.name)) {
          throw new Error(`Action "${action.constructor.name}" already registered for overlay "${forOverlay.name}"!`);
        }
        overlayActions.actions.push(action);
      }
    }
  }

  @EventSource(ResourceActionRegistrationEvent)
  registerResourceActions(forResource: Constructable<UnknownResource>, actions: IUnknownResourceAction[]): void {
    const resourceActions = this.resourceActions.find((a) => a.resourceClass === forResource);
    if (!resourceActions) {
      this.resourceActions.push({ actions: actions, resourceClass: forResource });
    } else {
      for (const action of actions) {
        if (resourceActions.actions.find((a) => a.constructor.name === action.constructor.name)) {
          throw new Error(`Action "${action.constructor.name}" already registered for resource "${forResource.name}"!`);
        }
        resourceActions.actions.push(action);
      }
    }
  }

  unregisterModelActions(forModel: Constructable<UnknownModel>): void {
    const modelActions = this.modelActions.find((a) => a.modelClass === forModel);
    if (!modelActions) {
      return;
    }

    modelActions.actions = [];
  }

  unregisterOverlayActions(forOverlay: Constructable<UnknownOverlay>): void {
    const overlayActions = this.overlayActions.find((a) => a.overlayClass === forOverlay);
    if (!overlayActions) {
      return;
    }

    overlayActions.actions = [];
  }
}

@Factory<TransactionService>(TransactionService)
export class TransactionServiceFactory {
  private static instance: TransactionService;

  static async create(): Promise<TransactionService> {
    const container = Container.getInstance();
    const [captureService, eventService, inputService, moduleContainer, overlayDataRepository, resourceDataRepository] =
      await Promise.all([
        container.get(CaptureService),
        container.get(EventService),
        container.get(InputService),
        container.get(ModuleContainer),
        container.get(OverlayDataRepository),
        container.get(ResourceDataRepository),
      ]);

    if (!this.instance) {
      this.instance = new TransactionService(
        captureService,
        eventService,
        inputService,
        moduleContainer,
        overlayDataRepository,
        resourceDataRepository,
      );
    }

    return this.instance;
  }
}
